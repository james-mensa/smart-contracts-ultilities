// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract Ballot {
    struct Voter {
        Party[] partiesApprove; // weight is accumulated by delegation
        bool voted; // if true, that person already voted
        address delegate; // person delegated to
        uint vote; // index of the voted proposal
        uint weight;
        address account;
    }
    struct Party {
        address account;
        bytes name;
    }

    struct Event {
        uint id;
        address chairperson;
        bytes32 name;
        uint startdate;
        uint enddate;
        Party[] parties;
        mapping(address => Voter) voters;
        mapping(uint => Pool) Ballots;
    }

    struct Candidate {
        bytes32 name; // short name (up to 32 bytes)
        uint voteCount; // number of accumulated votes
    }

    address[] public poolParties;
    uint public electionID;
    mapping(uint => Event) public Elections;

    struct Pool {
        uint id;
        mapping(address => Voter) voters;
        Candidate[] candidates;
        bool general;
        bytes32 name;
    }

    constructor() {
        electionID = 0;
    }


function deployElection(
    bytes32 name,
    uint startdate,
    uint enddate,
    Party[] memory _parties
) public {
    require(startdate < enddate, "Invalid election dates");
    // Increment election ID
    electionID++;

    // Create the Event struct for this election without initializing the mapping
    Event storage newElection = Elections[electionID];
    newElection.id = electionID;
    newElection.chairperson = msg.sender;
    newElection.name = name;
    newElection.startdate = startdate;
    newElection.enddate = enddate;

    // Populate the parties array
    for (uint i = 0; i < _parties.length; i++) {
        newElection.parties.push(_parties[i]);
    }
}}

    function addVoterToElection(uint _electionID, address _voter) public {
        Event storage election = Elections[_electionID];
        Party[] memory parties;
        election.voters[_voter] = Voter(parties, false, address(0), 0, 0);
    }

    function addVotersToElection(
        uint _electionID,
        address[] memory _voters
    ) public {
        Event storage election = Elections[_electionID];
        Party[] memory parties;
        for (uint i = 0; i < _voters.length; i++) {
            election.voters[_voters[i]] = Voter(
                parties,
                false,
                address(0),
                0,
                0
            );
        }
    }

    function addBallotEvent(
        uint election_id,
        bytes32[] memory _candidates,
        bool _general,
        bytes32 _name
    ) public {
          require(
        election_id<=electionID,
            "Event do not exist"
        );


        require(
            block.timestamp < Elections[election_id].startdate,
            "Adding new Pool not permitted"
        );

        Candidate[] memory candidates;
        for (uint i = 0; i < _candidates.length; i++) {
            candidates.push(Candidate({name: _candidates[i], voteCount: 0}));
        }

        // Get total number of ballots
        uint totalballot = Elections[election_id].Ballots.length;
        totalballot++;
        // Create new pool
        Pool memory newPool = Pool({
            id: totalballot,
            candidates: candidates,
            general: _general,
            name: _name
        });

        // Store the new pool in the Elections mapping
        Elections[election_id].Ballots[totalballot] = newPool;
    }

    function addManyVotersToElection(
        uint election_id,
        address[] memory _voters
    ) public {
        // Ensure the election exists
        require(election_id <= electionID, "Election does not exist");
        // Ensure the caller is the chairperson of the election
        require(
            msg.sender == Elections[election_id].chairperson,
            "Only chairperson can add voters"
        );

        // Loop through the array of voters and add each voter to the voters array of the specified election
        for (uint i = 0; i < _voters.length; i++) {
            Party[] memory _parties;
            Elections[election_id].voters.push(
                Voter({
                    partiesApprove: _parties, // Initialize with an empty array
                    voted: false,
                    delegate: address(0), // Initialize with address(0)
                    vote: 0, // Initialize with 0
                    weight: 1, // Assuming all voters have equal weight initially
                    account: _voters[i]
                })
            );
        }
    }

    function addVoterToPool(
        uint election_id,
        uint pool_id,
        address _voter
    ) public {
        require(election_id <= electionID, "Election does not exist");
        require(
            pool_id < Elections[election_id].Ballots.length,
            "Pool does not exist"
        );
        require(
            msg.sender == Elections[election_id].chairperson,
            "Only chairperson can add voters"
        );

     
        Elections[election_id].Ballots[pool_id].voters[_voter] = Voter({
                voted: false,
                delegate: address(0), // Initialize with address(0)
                vote: 0, // Initialize with 0
                weight: 1, // Assuming all voters have equal weight initially
                account: _voter
            });
    }

    function addManyVotersToPool(
        uint election_id,
        uint pool_id,
        address[] memory _voters
    ) public {
        require(election_id <= electionID, "Election does not exist");
        require(
            pool_id < Elections[election_id].Ballots.length,
            "Pool does not exist"
        );
        require(
            msg.sender == Elections[election_id].chairperson,
            "Only chairperson can add voters"
        );

        for (uint i = 0; i < _voters.length; i++) {
           Elections[election_id].Ballots[pool_id].voters[_voters[i]] = Voter({
                voted: false,
                delegate: address(0), // Initialize with address(0)
                vote: 0, // Initialize with 0
                weight: 1, // Assuming all voters have equal weight initially
                account: _voters[i]
            });
        }
    }

    modifier validateParty(address voter, uint election_id) {
        require(election_id <= electionID, "Election does not exist");
        bool valid;

        for (uint i = 0; i < Elections[election_id].parties.length; i++) {
            if (Elections[election_id].parties[i].account == msg.sender) {
                valid = true;
            }
        }
        require(valid, "Only Party can give right to vote.");

        bool authorized;
        for (
            uint i = 0;
            i < Elections[election_id].voters[voter].partiesApprove.length;
            i++
        ) {
            if (
                Elections[election_id]
                    .voters[voter]
                    .partiesApprove[i]
                    .account == msg.sender
            ) {
                authorized = true;
            }
        }
        require(!authorized, "you have already Authorized voter. Thank you");
        _;
    }

    function giveRightToVoteGeneral(
        uint election_id,
        address voter
    ) public validateParty(voter, election_id) {
        require(
            !Elections[election_id].voters[voter].voted,
            "The voter already voted."
        );

        Elections[election_id].voters[voter].partiesApprove.push(msg.sender);

        bool validated = Elections[election_id].voters[voter].partiesApprove.length ==Elections[election_id].parties.length;
          
        if (validated) {
            Elections[election_id].voters[voter].weight = 1;
        }
    }

